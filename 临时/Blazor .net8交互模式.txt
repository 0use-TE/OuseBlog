Blazor .net8交互模式
Blazor None 静态SSR
用户请求，服务端第一次会返回blazor.web.js(虽然不用Signair和wasm)和页面的HTML内容,由于需要增强式的路由导航和表单，故客户端仍需下载js文件，后续导航发起请求到服务器，被js文件捕捉，然后内部使用增强型导航，仍是发起请求，但是不是全部刷新，增强型表单底层是ajkx，服务器完全返回生成的HTML，故没有交互性。当然也不存在交互性路由。


Blazor Server 单页
用户请求,返回的也是Blazor.web.js,因为所有的Blazor Web App项目都返回同一个blazor.web.js脚本，如果开启了预渲染，会连同生成的html一起返回。然后js会发起请求到服务端建立持久web socket连接，此时客户端并没有razor逻辑，Only有页面，服务端有客户端的虚拟dom，此时客户端和服务端通过一个机制进行同步，客户端主要任务是将用户触发的事件通过signair传到服务端，服务端接收到处理对用事件的逻辑，维护dom状态，然后把需要更改的内容传回客户端，客户端进行更改，然后循环....   后续路由时候，由于不是交互性路由，仍是通过js捕捉导航，发送请求到服务端，服务端返回HTML内容注意有预渲染，但由于已经加载了@body的其他部分，所以返回的只有这部分，包括预渲染后，服务端通过比较差异，把虚拟dom的更改部分返回到客户端，客户端重新渲染(预渲染时候并没有创建虚拟dom)。对于js操作，由于服务端没有js环境，所以是把指令发送到客户端，客户端执行，对于有返回值的，会通过signair返回到服务端，注意，如果执行的js更改了客户端的dom，这些不会传到服务端，因为这会消耗很多性能，而且违背了服务端渲染的初衷，比如通过js删掉了某个元素，后续服务端重新渲染时就会把删掉的元素还原，因此我们不应该通过js直接对浏览器的真实dom执行CRUD，这些应该交给服务端或者避免执行类似的操作。如果服务器切换到静态SSR页面，不会直接断开Signair连接，如果迅速切换回来了(实测1秒内)可以继续维持通道，否则就会断开。

Blazor Server 全局
全局交互性和单页的主要区别在于全部交互性开启了交互性路由，开启交互性路由后，先说好处，当进行路由切换时候除了第一次预渲染会发起http请求，后续的所有导航都会走Signair通道，并且不会再进行预渲染，这大大加快了导航速度，坏处是所有页面都会继承这个交互性，且无法再切换回静态SSR，理由是所有的操作都走的Signair通道
对比，我感觉如果使用server就使用全局吧，其实主要差异是静态ssr，走signair的话，肯定是要比http请求静态ssr快的，既然你都需要交互性了，其他页面即使不需要交互性，也没必要必须要求他是静态ssr，在静态ssr页面不使用交互性就行了，还能降低复杂度。

Blazor  独立 WebAssemply
Blazor 独立Wasm是纯静态的，也就意味着可以直接托管在GitHub pages等服务器上，且目标机器不需要装.net运行时，所以的逻辑都在客户端处理，服务端只是提供文件下载。首先，用户请求页面(index.html)，服务端器会把编译为wasm的CLR，必要的css，js，razor组件编译为wasm的内容，以及使用的第三方dll会编译成wasm。初次访问，不压缩情况加载大约有11M(有点大)，用户必须等待加载，gpiz或者br压缩后分别为4M和3M,也算能接受，之后再次访问因为运行时等已经缓存了，几乎秒开。这种模式跟vue，react等很像，也比较好理解。

Blazor WebAssemply 单页
可以理解为独立wasm＋后端，但跟一个解决方案建一个独立的wasm项目＋asp.net core web api项目不一样，这个项目在web api项目的基础上增强了wasm，带有预渲染，同时可以使用静态SSR，但缺点是由于有预渲染，所以导致该页面并不存在加载指示条，您可以如下测试，创建好项目并启动，迅速点击Counter页面的增加，您会看到没有响应，因为此时处于预渲染，等wasm加载完毕才会具有交互性，在此期间用户只能查看，并且wasm加载完毕后，可能会闪烁一下，因为会重新通过客户端的wasm重新渲染虚拟dom树，独立wasm最大的问题就是初次慢，但我感觉预渲染方案并没有很好的解决这个问题，比如服务器网速很慢，要10秒才能将wasm下载到客户端，这就意味着，如果是独立wasm客户就要等待加载10秒，wasm交互性项目就会出现用户能立即看到页面，但是没有交互性，也就意味着这10秒用户点击按钮，提交表单等等操作不起作用，直到10秒后页面闪烁一下客户端才有交互性，我认为这种体验超级糟糕，用户甚至以为是网站的bug，我的话，会直接离开页面。之后用户切换页面后，还会具有预渲染，但由于客户端已经加载完了wasm，所以会秒切，还有种情况是如果在client项目中的razor组件没有添加wasm交互性，该页面也会预渲染然后客户端渲染，虽然客户端渲染了，但仍没有交互性。既然wasm都已经加载了，但还是要预渲染，因为Route组件在服务端，我认为这是没有必要的，所以我这种模式使用的场景很少。

Blazor WebAssemply 全局
和单页工作原理差不多，主要区别在于路由和预渲染，全局开启了交互性路由。第一次发起请求，js和预渲染以及Route组件一起返回到客户端，然后加载wasm，等待加载完毕后，开启交互性，之后再进行导航，由于Route组件在客户端了，所以将无法处理寻找到服务端的可路由页面，切换到其他wasm项目时候，将不在再使用预渲染，直接由客户端处理。以下的示例展示了第一次预渲染与路由完全在客户端，如果您在服务端建立一个静态SSR项目，然后从浏览器输入该页面的url（注意是手动输入，而不是页面导航），您会发现成功查看到到了想要的页面，但是马上又会出现NotFound,这是因为第一次访问是http请求，所以返回了预渲染结果(不是由客户端导航，由服务端终结点导航)，当加载wasm完毕后，客户端会尝试路由到该页面，但是由于找不到就会返回404。虽然无法使用静态SSR了，但是感觉比单页wasm交互性好。

Blazor Auto 单页
第一次访问返回预渲染和js，然后建立signair连接，具有server交互性，然后不断加载wasm(注意是所有页面，该不是仅加载该页面)，当加载完毕后，再次访问其他也是Auto交互性的页面均会以wasm＋预渲染形式处理，如果访问的是静态ssr，那么组件必须放在服务端。server的话，服务端和客户端都可以。如果是wasm或者auto就必须放在客户端项目，wasm好理解，auto必须放是因为第二次就会以wasm运行，第一次不会报错，第二次就会报错了。所以Auto项目是可以同时具有四种交互性的，但是这样无疑增加了项目的复杂度，虽然先服务端在客户端的使用体验确实好，但就会造成不少的麻烦，比如一个Auto页面要从数据库加载东西，第一次以服务端项目启动，而且您的api也写在了后端，明明可以直接注入db获取的，但是由于下次是wasm加载，就无法使用db而是使用http请求，服务端加载服务端的api，这是不是很疯狂，除非您通过判断当前的环境来写两套逻辑，并且DI也需要判断，非常麻烦！所以对于要从api加载的页面，就不应该使用Auto交互性，所以只有部分页面才能使用Auto交互性。因此这种交互性，我认为下面的情况超级适合，就是网站的主页面使用Auto，用户第一次访问时候，不需要交互性，后台下载wasm，然后其他页面使用wasm，如果网速够快，可以在用户进入其他页面前下载完全部的wasm，否则就会出现单页wasm的困境，用户一直查看的是预渲染，无法交互！直到彻底下载完毕。这个项目是灵活，但是感觉不好用。。。

Blazor Auto 全局
全局可以理解为全局wasm和全局server的结合体，所有的组件均在客户端项目中，开发者不应该指定交互性，因为交互性路由要不是浏览器内部路由要不是Signair路由，并且路由组件位于客户端且不会具有预渲染。

预渲染
对于Blazor Web App项目，除了静态ssr，都可以具有预渲染，预渲染开启后，会响应请求同时返回服务端直接渲染的HTML内容，注意不会触发OnRenderAftered回调。